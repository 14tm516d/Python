練習問題 11.1 ファイルwords.txt を読み込み、英単語をキーとする辞書を作成せよ。
値を何にするかは問わない。そして演算子in を使ってある文字列がその辞書にあるかどうかを調べる関数を作成せよ。

def makedict(words):
	d = dict()
	j = 0
	for i in words:
		d[i] = j
		j += 1
	return d

def in_dict(d,word):
	return word in d

練習問題 11.2 
辞書にはget というメソッドがある。これは引数としてキーとその既定値を受けとる。
そのキーが存在すればそのアイテムの値を戻すが、なければその既定値を戻す。
>>>h = histogram('a')
>>>print h
{'a', 1}
>>>h.get('a', 0)
1
>>>h.get('b', 0)
0
このget を使って関数histogram をよりコンパクトに書け。関数の本体にあるif 文を無くすことができるはずだ。


def histogram2(s):
	d = dict()
	for c in s:
		d[c] = d.get(c,0) + 1
	return d

print histogram2("ahkljdsahfoiuhbinkjcnkjahoeuihfuiasdjjasdhfuiw")

以下実行結果
{'a': 5, 'c': 1, 'b': 1, 'e': 1, 'd': 3, 'f': 3, 'i': 5, 'h': 6, 'k': 3, 'j': 5, 'l': 1, 'o': 2, 'n': 2, 's': 3, 'u': 4, 'w': 1}

練習問題 11.3 
辞書のキーをリストとして返すメッソドにkeys がある。
print_hist を修正してキーがアルファベット順に表示されるようにせよ。

def print_hist(h):
	for c in sorted(h.keys()):
		print c, h[c]

ソートする前の結果
a 5
c 1
b 1
e 1
d 3
f 3
i 5
h 6
k 3
j 5
l 1
o 2
n 2
s 3
u 4
w 1

ソート後の実行結果
a 5
b 1
c 1
d 3
e 1
f 3
h 6
i 5
j 5
k 3
l 1
n 2
o 2
s 3
u 4
w 1

練習問題 11.4 
関数reverse_lookup は値v をマップする全てのキーをリストとして戻す。
この関数を作成せよ。キーが一つもないときは空リストを返すものとする。

def reverse_lookup(d,value):
	l = []
	for i in d:
		if (value == d[i]):
			l += i
	return l

練習問題 11.3 
辞書にたいするメソッドsetdefaut のドキュメンテーションを読み、関数invert_dict をコンパクトに書け。


練習問題 11.8 
大きな整数の指数は暗号の公開キーの一般的なアルゴリズムの基礎である。
RSA アルゴリズムに関するWikipedia(http://en.wikipedia.org/wiki/RSA)
を読み、メッセージをコード化、またはデコード化する関数を書け。

#ユークリッド

def gcd(a,b) :
	if (b == 0):
		return a
	else:
		while a % b != 0:
			c = b
			b = a % b
			a = c
		return b

#拡張ユークリッド

def Euclid(a,b):
	x0=1;y0=0;z0=a	#(x0,y0,z0)=(1,0,a)とおく
	x1=0;y1=1;z1=b	#(x1,y1,z1)=(0,1,b)とおく
	x2=0;y2=0;z2=0
	q=0
	while(z1>0):
		q = z0 // z1
		x2=x1;y2=y1;z2=z1
		x1=x0-q*x1; y1=y0-q*y1; z1=z0%z1
		x0=x2;y0=y2;z0=z2
	return(x0,y0,z0)


#バイナリ法
def exp(a,b,n):
	y=1
	z=a
	while b:
		if b & 1:	#ビット演算
			y = (y*z) % n
		z = (z*z) % n
		b >>= 1 	#ビットシフト
	return y

#eとdを返す関数
def ex(p,q,a):
	n=p*q
	a=e
	b=(p-1)*(q-1)
	d=Euclid(a,b)
	return n,d[0]

#暗号化
def enc(m,e,n):
	c=exp(m,e,n)
	return c

#複合化
def com(c,d,n):
	m=exp(c,d,n)
	return m

#print'素数 p= ',
#p = input()
#print'素数 q= ',
#q = input()
#print'公開鍵 e= ',
#e = input()
#print '平文 M= ',
#m = input()

p=33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
q=36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917
e=65537

m=123456789


if(gcd(p,q)!= 1 ):
	print u'p,qが互いに素数でない'
	exit(1)	

a=e
b=(p-1)*(q-1)

n,d = ex(p,q,a)
if(d<0):	#dがマイナスの場合
	d=d+b
print u"公開鍵 n= %d" % n

print'秘密鍵 d= %d' % d

print "メッセージ m= %d" % m
#暗号化
c = enc(m,e,n)
print u"暗号化",
print'C =%d' % c

#複合化
print u"複合化",
print 'M =%d' % (com(c,d,n))

以下実行結果
公開鍵 n= 1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413
秘密鍵 d= 703813872109751212728960868893055483396831478279095442779477323396386489876250832944220079595968592852532432488202250497425262918616760886811596907743384527001944888359578241816763079495533278518938372814827410628647251148091159553
メッセージ m= 123456789
暗号化 C =50188308259591452379261261527991509438436342200928883462058091757107129200633901397352543428431099864929045014268338950751419214557694557692083786512945785234619539123218009165422900347487004059123489920048067091047389406661271673
複合化 M =123456789

